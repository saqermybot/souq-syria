import { pool } from "../../db/pool.js";
import { sendPushToGuest } from "../push/push.service.js";

/**
 * Golden Path Messages Service (Rebuild v1)
 * - Guest-first
 * - Minimal surface area
 * - No polling assumptions
 * - No mark-read / unread logic (stubbed for now to keep routes stable)
 * - Push is sent AFTER message is saved (best-effort)
 */

export async function getOrCreateThread({ adId, sellerId, buyerGuestId }) {
  const r = await pool.query(
    `INSERT INTO threads (ad_id, seller_id, buyer_guest_id)
     VALUES ($1,$2,$3)
     ON CONFLICT (ad_id, seller_id, buyer_guest_id)
     DO UPDATE SET last_message_at = threads.last_message_at
     RETURNING id`,
    [adId, sellerId, buyerGuestId]
  );
  return r.rows[0].id;
}

export async function listInbox({ guestId }) {
  const r = await pool.query(
    `SELECT
        t.id,
        t.ad_id,
        t.seller_id,
        t.buyer_guest_id,
        t.last_message_at,
        a.title AS ad_title,
        (a.images->>0) AS ad_image,
        COALESCE(s.company_name, s.display_name, 'Seller') AS seller_name,
        s.is_verified AS seller_is_verified,
        s.guest_id AS seller_guest_id
     FROM threads t
     JOIN ads a ON a.id = t.ad_id
     JOIN sellers s ON s.id = t.seller_id
     WHERE t.buyer_guest_id = $1 OR s.guest_id = $1
     ORDER BY t.last_message_at DESC NULLS LAST, t.id DESC
     LIMIT 100`,
    [guestId]
  );
  return r.rows;
}

export async function getThread({ threadId, guestId }) {
  const r = await pool.query(
    `SELECT
        t.id, t.ad_id, t.seller_id, t.buyer_guest_id, t.last_message_at,
        a.title AS ad_title,
        (a.images->>0) AS ad_image,
        COALESCE(s.company_name, s.display_name, 'Seller') AS seller_name,
        s.is_verified AS seller_is_verified,
        s.guest_id AS seller_guest_id,
        t.buyer_last_read_at,
        t.seller_last_read_at
     FROM threads t
     JOIN ads a ON a.id = t.ad_id
     JOIN sellers s ON s.id = t.seller_id
     WHERE t.id = $1
     LIMIT 1`,
    [threadId]
  );

  const t = r.rows[0];
  if (!t) return null;

  if (guestId && t.buyer_guest_id !== guestId && t.seller_guest_id !== guestId) {
    return { forbidden: true };
  }

  return t;
}

export async function listMessages({ threadId }) {
  const r = await pool.query(
    `SELECT id, sender_role, sender_guest_id, text, created_at
     FROM messages
     WHERE thread_id = $1
     ORDER BY created_at ASC
     LIMIT 500`,
    [threadId]
  );
  return r.rows;
}

export async function sendMessage({ threadId, guestId, text }) {
  // Fetch thread parties
  const t = await pool.query(
    `SELECT t.id, t.buyer_guest_id, s.guest_id AS seller_guest_id
     FROM threads t
     JOIN sellers s ON s.id = t.seller_id
     WHERE t.id = $1
     LIMIT 1`,
    [threadId]
  );
  if (t.rowCount === 0) return { ok: false, error: "NOT_FOUND" };

  const row = t.rows[0];

  // Authorization
  if (row.buyer_guest_id !== guestId && row.seller_guest_id !== guestId) {
    return { ok: false, error: "FORBIDDEN" };
  }

  const role = row.seller_guest_id === guestId ? "seller" : "buyer";

  // Save message
  const m = await pool.query(
    `INSERT INTO messages (thread_id, sender_role, sender_guest_id, text)
     VALUES ($1,$2,$3,$4)
     RETURNING id, created_at`,
    [threadId, role, guestId, text]
  );

  // Update last activity
  await pool.query(`UPDATE threads SET last_message_at = now() WHERE id = $1`, [threadId]);

  // Push notify other party (best-effort)
  try {
    const targetGuestId = role === "buyer" ? row.seller_guest_id : row.buyer_guest_id;
    if (targetGuestId) {
      await sendPushToGuest({
        guestId: targetGuestId,
        payload: {
          title: "Souq Syria",
          body: "رسالة جديدة ✉️",
          url: `/messages/thread/${threadId}`
        }
      });
    }
  } catch {
    // never block message send on push errors
  }

  return {
    ok: true,
    message: {
      id: m.rows[0].id,
      created_at: m.rows[0].created_at,
      sender_role: role
    }
  };
}

/**
 * TEMP STUBS (to keep existing routes working until Patch 2)
 * We intentionally disable these features during rebuild.
 */
export async function markThreadRead() {
  return { ok: true };
}

export async function unreadCount() {
  return 0;
}
